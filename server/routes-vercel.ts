import type { Express } from "express";
import { createServer, type Server } from "http";
import fs from 'fs';
import path from 'path';
import { storage } from "./storage.js";
import { exportDatabase, importDatabase } from './database/backup.js';
import { setupAuth } from './auth.js';
import { startRateUpdates } from './rates.js';
import express from 'express';
import fetch from 'node-fetch';

// –†–∞—Å—à–∏—Ä—è–µ–º —Ç–∏–ø—ã —Å–µ—Å—Å–∏–∏
declare global {
  namespace Express {
    interface Session {
      user?: string;
    }
  }
}
import { getExchangeRate, createExchangeTransaction, getTransactionStatus } from './exchange-service.js';
import { getNews } from './news-service.js';
import { seaTableManager } from './utils/seatable.js';
import { generateValidAddress, validateCryptoAddress, getSeedPhraseForUser } from './utils/crypto.js';
import { hasBlockchainApiKeys } from './utils/blockchain.js';
import { generateAddressesForUser, isValidMnemonic, getAddressesFromMnemonic } from './utils/seed-phrase.js';
// import { generateNFTImage } from './utils/nft-generator.js'; // –ò—Å–∫–ª—é—á–µ–Ω–æ –¥–ª—è Vercel
import { db } from './db.js';
import { eq } from 'drizzle-orm';
import { nfts, nftCollections } from '../shared/schema.js';
import nftRoutes from './controllers/nft-controller.js';
import nftImportRoutes from './controllers/nft-import-controller.js';
import nftMarketplaceRoutes from './controllers/nft-marketplace-controller.js';
// import nftServerController from './controllers/nft-server-controller.js'; // –ò—Å–∫–ª—é—á–µ–Ω–æ –¥–ª—è Vercel
import { staticAssetsRouter } from './routes/static-assets.js';
import { serveStatic } from './vite-vercel.js';
import { setupDebugRoutes } from "./debug.js";

// Auth middleware
function ensureAuthenticated(req: express.Request, res: express.Response, next: express.NextFunction) {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ message: "–ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è" });
}

// Vercel-—Å–æ–≤–º–µ—Å—Ç–∏–º–∞—è –≤–µ—Ä—Å–∏—è registerRoutes (–±–µ–∑ WebSocket –∏ —Å–ª–æ–∂–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π)
export async function registerRoutes(app: Express): Promise<Server> {
  console.log('üîß –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–æ–≤ –¥–ª—è Vercel...');

  // –ë–∞–∑–æ–≤–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Express
  app.use(express.json({ limit: '10mb' }));
  app.use(express.urlencoded({ extended: true, limit: '10mb' }));

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
  setupAuth(app);

  // –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—Å—É—Ä—Å—ã –¥–ª—è NFT
  app.use('/bored_ape_nft', express.static(path.join(process.cwd(), 'bored_ape_nft')));
  app.use('/public/assets/nft', express.static(path.join(process.cwd(), 'client/public/assets/nft')));
  app.use('/bayc_official', express.static(path.join(process.cwd(), 'client/public/bayc_official')));
  app.use(staticAssetsRouter);

  // API –º–∞—Ä—à—Ä—É—Ç—ã
  app.use('/api/nft', nftRoutes);
  app.use('/api/nft/marketplace', nftMarketplaceRoutes);
  app.use('/api/nft-import', nftImportRoutes);
  // app.use('/api/nft-server', nftServerController); // –ò—Å–∫–ª—é—á–µ–Ω–æ –¥–ª—è Vercel (—Ç—è–∂–µ–ª—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏)

  // –û—Ç–ª–∞–¥–æ—á–Ω—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã
  setupDebugRoutes(app);

  // –û—Å–Ω–æ–≤–Ω—ã–µ API endpoints
  app.get("/api/rates", async (req, res) => {
    try {
      const rates = await storage.getLatestExchangeRates();
      res.json(rates);
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—É—Ä—Å–æ–≤:", error);
      res.status(500).json({ message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç" });
    }
  });

  app.get("/api/cards", ensureAuthenticated, async (req, res) => {
    try {
      if (!(req.session as any)?.user) {
        return res.status(401).json({ message: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω" });
      }

      const username = (req.session as any).user as string;
      const user = await storage.getUserByUsername(username);
      
      if (!user) {
        return res.status(404).json({ message: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
      }

      const cards = await storage.getCardsByUserId(user.id);
      res.json(cards);
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ä—Ç:", error);
      res.status(500).json({ message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–∞—Ä—Ç" });
    }
  });

  // NFT –∫–æ–ª–ª–µ–∫—Ü–∏–∏
  app.get('/api/nft-collections', ensureAuthenticated, async (req, res) => {
    try {
      if (!(req.session as any)?.user) {
        return res.status(401).json({ error: '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è' });
      }
      
      const username = (req.session as any).user as string;
      const user = await storage.getUserByUsername(username);
      
      if (!user) {
        return res.status(404).json({ error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
      }
      
      const collections = await db.select().from(nftCollections);
      const collectionsWithNFTs = await Promise.all(collections.map(async (collection) => {
        const collectionNFTs = await db.select().from(nfts).where(eq(nfts.collectionId, collection.id));
        return {
          ...collection,
          nfts: collectionNFTs
        };
      }));
      
      res.status(200).json(collectionsWithNFTs);
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–æ–ª–ª–µ–∫—Ü–∏–π NFT:', error);
      res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–æ–ª–ª–µ–∫—Ü–∏–π NFT' });
    }
  });

  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫—Ä–∏–ø—Ç–æ–∞–¥—Ä–µ—Å–æ–≤
  app.get("/api/crypto/seed-phrase", ensureAuthenticated, async (req, res) => {
    try {
      if (!(req.session as any)?.user) {
        return res.status(401).json({ message: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω" });
      }

      const username = (req.session as any).user as string;
      const user = await storage.getUserByUsername(username);
      
      if (!user) {
        return res.status(404).json({ message: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
      }

      const seedPhrase = getSeedPhraseForUser(user.id);
      res.json({ seedPhrase });
    } catch (error) {
      console.error("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ seed-—Ñ—Ä–∞–∑—ã:", error);
      res.status(500).json({ message: "–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ seed-—Ñ—Ä–∞–∑—ã" });
    }
  });

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ñ–∞–π–ª–æ–≤ –¥–ª—è production
  if (process.env.NODE_ENV === 'production') {
    serveStatic(app);
  }

  console.log('‚úÖ –ú–∞—Ä—à—Ä—É—Ç—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –¥–ª—è Vercel');
  
  // –í–æ–∑–≤—Ä–∞—â–∞–µ–º mock server –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
  return createServer(app);
}

// Default export –¥–ª—è Vercel API
export default registerRoutes;